do
	if game.Players.LocalPlayer:WaitForChild("PlayerGui"):FindFirstChild("RaitoLib") then
		game.Players.LocalPlayer:WaitForChild("PlayerGui"):FindFirstChild("RaitoLib"):Destroy()
	end
end
local a = game:GetService("UserInputService")
local b = game:GetService("TweenService")
local function c(c, d)
	local e = nil
	local f = nil
	local g = nil
	local h = nil
	local function i(a)
		local a = a.Position - g
		local a = UDim2.new(h.X.Scale, h.X.Offset + a.X, h.Y.Scale, h.Y.Offset + a.Y)
		local a = b:Create(d, TweenInfo.new(0.2), {Position = a})
		a:Play()
	end
	c.InputBegan:Connect(
		function(a)
			if a.UserInputType == Enum.UserInputType.MouseButton1 or a.UserInputType == Enum.UserInputType.Touch then
				e = true
				g = a.Position
				h = d.Position
				a.Changed:Connect(
					function()
						if a.UserInputState == Enum.UserInputState.End then
							e = false
						end
					end
				)
			end
		end
	)
	c.InputChanged:Connect(
		function(a)
			if a.UserInputType == Enum.UserInputType.MouseMovement or a.UserInputType == Enum.UserInputType.Touch then
				f = a
			end
		end
	)
	a.InputChanged:Connect(
		function(a)
			if a == f and e then
				i(a)
			end
		end
	)
end
local d = {}
function d:AddWindow(d, e)
	local e = e or Enum.KeyCode.RightControl
	local f = false
	local g = ""
	local h = Instance.new("ScreenGui")
	h.Name = "RaitoLib"
	h.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
	h.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	local i = Instance.new("Frame")
	i.Name = "Main"
	i.Parent = h
	i.AnchorPoint = Vector2.new(0.5, 0.5)
	i.BackgroundColor3 = Color3.fromRGB(20, 20, 20) -- Black background
	i.BackgroundTransparency = 0
	i.BorderSizePixel = 0
	i.ClipsDescendants = true
	i.Position = UDim2.new(0.499526083, 0, 0.499241292, 0)
	i.Size = UDim2.new(0, 600, 0, 350)
	local h = Instance.new("UICorner")
	h.Name = "MainCorner"
	h.CornerRadius = UDim.new(0, 9)
	h.Parent = i
	local h = Instance.new("ImageButton")
	h.Parent = i
	h.BackgroundColor3 = Color3.fromRGB(255, 255, 255) -- White background for close button
	h.BackgroundTransparency = 1
	h.BorderColor3 = Color3.fromRGB(0, 0, 0)
	h.BorderSizePixel = 0
	h.Position = UDim2.new(0.953, 0, 0.029, 0)
	h.Size = UDim2.new(0, 17, 0, 18)
	h.Image = "rbxassetid://9886659671"
	h.ImageColor3 = Color3.fromRGB(255, 255, 255) -- White X
	h.MouseEnter:Connect(
		function()
			b:Create(
				h,
				TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
				{ImageColor3 = Color3.fromRGB(200, 200, 200)} -- Light gray hover
			):Play()
		end
	)
	h.MouseLeave:Connect(
		function()
			b:Create(
				h,
				TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
				{ImageColor3 = Color3.fromRGB(255, 255, 255)} -- Back to white
			):Play()
		end
	)
	h.MouseButton1Click:Connect(
		function()
			do
				local a = game.Players.LocalPlayer.PlayerGui:FindFirstChild("RaitoLib")
				if a then
					a:Destroy()
				end
			end
			do
				local a = game.Players.LocalPlayer.PlayerGui:FindFirstChild("Visible")
				if a then
					a:Destroy()
				end
			end
		end
	)
	local h = Instance.new("Frame")
	h.Name = "Top"
	h.Parent = i
	h.BackgroundColor3 = Color3.fromRGB(20, 20, 20) -- Black top bar
	h.BackgroundTransparency = 1.000
	h.BorderSizePixel = 0
	h.Size = UDim2.new(0, 600, 0, 38)
	local j = Instance.new("UICorner")
	j.Name = "MainCorner"
	j.CornerRadius = UDim.new(0, 9)
	j.Parent = h
	local j = Instance.new("Frame")
	j.Name = "Page"
	j.Parent = i
	j.BackgroundColor3 = Color3.fromRGB(15, 15, 15) -- Slightly darker black sidebar
	j.BackgroundTransparency = 0
	j.BorderSizePixel = 0
	j.Position = UDim2.new(0, 0, 0, 38)
	j.Size = UDim2.new(0, 125, 0, 312)
	local k = Instance.new("UICorner")
	k.Name = "MainCorner"
	k.CornerRadius = UDim.new(0, 9)
	k.Parent = j
	local k = Instance.new("Frame")
	k.Parent = j
	k.BackgroundColor3 = Color3.fromRGB(255, 255, 255) -- White sidebar accent line
	k.BorderColor3 = Color3.fromRGB(0, 0, 0)
	k.BorderSizePixel = 0
	k.Position = UDim2.new(1, 0, 0.001, 0)
	k.Size = UDim2.new(0, 1, 0, 273)
	local k = Instance.new("Frame")
	k.Parent = j
	k.BackgroundColor3 = Color3.fromRGB(255, 255, 255) -- White horizontal line
	k.BorderColor3 = Color3.fromRGB(0, 0, 0)
	k.BorderSizePixel = 0
	k.Position = UDim2.new(0, 0, 0.322, -101)
	k.Size = UDim2.new(0, 600, 0, 1)
	local k = Instance.new("Frame")
	k.Parent = j
	k.BackgroundColor3 = Color3.fromRGB(255, 255, 255) -- White horizontal line
	k.BorderColor3 = Color3.fromRGB(0, 0, 0)
	k.BorderSizePixel = 0
	k.Position = UDim2.new(0, 0, 1.2, -101)
	k.Size = UDim2.new(0, 600, 0, 1)
	function hidetext(a)
		local b = 3
		local c = string.sub(a, 1, b)
		local a = string.rep("*", #a - b)
		local a = c .. a
		return a
	end
	local k = hidetext(game.Players.LocalPlayer.Name)
	local l = math.floor(workspace.DistributedGameTime + 0.5)
	local m = math.floor(l / 60 ^ 2) % 24
	local m = math.floor(l / 60 ^ 1) % 60
	local l = math.floor(l / 60 ^ 0) % 60
	local l = Instance.new("TextLabel")
	l.Name = "PlayerName"
	l.Parent = j
	l.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	l.BackgroundTransparency = 1.000
	l.Position = UDim2.new(0.136, 0, 1.02, -33)
	l.Size = UDim2.new(0, 15, 0, 15)
	l.Font = Enum.Font.GothamSemibold
	l.Text = "        Welcome, " .. k
	l.TextColor3 = Color3.fromRGB(240, 240, 240) -- Light gray text
	l.TextSize = 12.000
	l.TextXAlignment = Enum.TextXAlignment.Left
	local k = Instance.new("TextLabel")
	k.Name = "Statsetc"
	k.Parent = j
	k.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	k.BackgroundTransparency = 1.000
	k.Position = UDim2.new(3.2, 0, 1.02, -33)
	k.Size = UDim2.new(0, 15, 0, 15)
	k.Font = Enum.Font.GothamSemibold
	k.Text = ""
	k.TextColor3 = Color3.fromRGB(240, 240, 240) -- Light gray stats
	k.TextSize = 12.000
	k.TextXAlignment = Enum.TextXAlignment.Left
	function UpdateStats()
		local a = math.floor(workspace.DistributedGameTime + 0.5)
		local b = math.floor(a / 60 ^ 2) % 24
		local c = math.floor(a / 60 ^ 1) % 60
		local a = math.floor(a / 60 ^ 0) % 60
		k.Position = UDim2.new(3.2, 0, 1.02, -33)
		k.Text = "Hours : " .. b .. " Minutes : " .. c .. " Seconds : " .. a
	end
	spawn(
		function()
			while task.wait(1) do
				pcall(
					function()
						UpdateStats()
					end
				)
			end
		end
	)
	local k = Instance.new("Frame")
	local l = Instance.new("UICorner")
	local m = Instance.new("Frame")
	local n = Instance.new("UICorner")
	local o = Instance.new("ImageLabel")
	local p = Instance.new("UICorner")
	local q = Instance.new("Frame")
	local r = Instance.new("UICorner")
	k.Name = "Avadarrrrr"
	k.Parent = j
	k.AnchorPoint = Vector2.new(0, 0.5)
	k.BackgroundColor3 = Color3.fromRGB(255, 255, 255) -- White avatar background
	k.BackgroundTransparency = 1.000
	k.BorderColor3 = Color3.fromRGB(0, 0, 0)
	k.BorderSizePixel = 0
	k.Position = UDim2.new(-0.85, 0, 0.939, 0)
	k.Size = UDim2.new(0, 38, 0, 38)
	l.CornerRadius = UDim.new(1, 0)
	l.Parent = k
	m.Name = "hhhh"
	m.Parent = k
	m.BackgroundColor3 = Color3.fromRGB(255, 255, 255) -- White avatar frame
	m.BorderColor3 = Color3.fromRGB(0, 0, 0)
	m.Position = UDim2.new(2.97368431, 0, 0.105263159, 0)
	m.Size = UDim2.new(0, 30, 0, 30)
	n.CornerRadius = UDim.new(1, 0)
	n.Parent = m
	o.Parent = m
	o.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	o.BackgroundTransparency = 1.000
	o.BorderColor3 = Color3.fromRGB(0, 0, 0)
	o.BorderSizePixel = 0
	o.Position = UDim2.new(0, 3, 0, 3)
	o.Size = UDim2.new(0, 24, 0, 24)
	o.Image = "rbxthumb://type=AvatarHeadShot&id=" .. game.Players.LocalPlayer.UserId .. "&w=420&h=420"
	p.CornerRadius = UDim.new(1, 0)
	p.Parent = o
	q.Name = "sdsds"
	q.Parent = k
	q.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	q.BackgroundTransparency = 1.000
	q.BorderColor3 = Color3.fromRGB(0, 0, 0)
	q.BorderSizePixel = 0
	q.Position = UDim2.new(3.05263162, 0, 0.0526315793, 5)
	q.Size = UDim2.new(0, 24, 0, 24)
	local k = Instance.new("UIStroke")
	k.Name = "UIStroke"
	k.Parent = q
	k.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	k.Color = Color3.fromRGB(50, 50, 50) -- Dark gray stroke
	k.LineJoinMode = Enum.LineJoinMode.Round
	k.Thickness = 1
	k.Transparency = 0
	k.Enabled = true
	k.Archivable = true
	r.CornerRadius = UDim.new(1, 0)
	r.Parent = q
	local k = Instance.new("TextLabel")
	k.Name = "NameHub"
	k.Parent = j
	k.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	k.BackgroundTransparency = 1.000
	k.Position = UDim2.new(0.136, 0, 0.018, -33)
	k.Size = UDim2.new(0, 15, 0, 15)
	k.Font = Enum.Font.GothamSemibold
	k.Text = d
	k.TextColor3 = Color3.fromRGB(255, 255, 255) -- White hub name
	k.TextSize = 12.000
	k.TextXAlignment = Enum.TextXAlignment.Left
	local d = Instance.new("TextButton")
	d.Name = "Discord"
	d.Parent = j
	d.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	d.BackgroundTransparency = 1.000
	d.BorderColor3 = Color3.fromRGB(0, 0, 0)
	d.BorderSizePixel = 0
	d.Position = UDim2.new(0.879999995, 0, 0.0184615701, -33)
	d.Size = UDim2.new(0, 124, 0, 15)
	d.Font = Enum.Font.Gotham
	d.Text = ""
	d.TextColor3 = Color3.fromRGB(150, 150, 150) -- Gray discord text
	d.TextSize = 12.000
	d.TextXAlignment = Enum.TextXAlignment.Left
	d.MouseEnter:Connect(
		function()
			b:Create(
				d,
				TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
				{TextColor3 = Color3.fromRGB(255, 255, 255)} -- White hover
			):Play()
		end
	)
	d.MouseLeave:Connect(
		function()
			b:Create(
				d,
				TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
				{TextColor3 = Color3.fromRGB(150, 150, 150)} -- Back to gray
			):Play()
		end
	)
	d.MouseButton1Click:Connect(
		function()
			setclipboard()
			d.Text = "| Copied"
			wait(2)
			d.Text = ""
		end
	)
	local d = Instance.new("ScrollingFrame")
	d.Name = "ScrollPage"
	d.Parent = j
	d.Active = true
	d.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	d.BackgroundTransparency = 1.000
	d.BorderSizePixel = 0
	d.Position = UDim2.new(-0.1, 0, 0.011, 0)
	d.Size = UDim2.new(0, 135, 0, 273)
	local j = Instance.new("UIListLayout")
	j.Name = "PageList"
	j.Parent = d
	j.SortOrder = Enum.SortOrder.LayoutOrder
	j.Padding = UDim.new(0, 7)
	local l = Instance.new("UIPadding")
	l.Name = "PagePadding"
	l.Parent = d
	l.PaddingTop = UDim.new(0, 5)
	l.PaddingLeft = UDim.new(0, 28)
	local l = Instance.new("UICorner")
	l.Name = "ScrollPageCorner"
	l.CornerRadius = UDim.new(0, 9)
	l.Parent = d
	local l = Instance.new("Folder")
	l.Name = "TabFolder"
	l.Parent = i
	c(h, i)
	local c = false
	a.InputBegan:Connect(
		function(a)
			if a.KeyCode == e then
				if c == false then
					c = true
					i:TweenSize(UDim2.new(0, 0, 0, 0), "In", "Quad", 0.2, true)
				else
					c = false
					i:TweenSize(UDim2.new(0, 600, 0, 350), "Out", "Quad", 0.2, true)
				end
			end
		end
	)
	local s = game:GetService("TweenService")
	local a = {}
	function a:AddTab(a)
		local c = Instance.new("TextButton")
		c.Name = "PageButton"
		c.Parent = d
		c.BackgroundColor3 = Color3.fromRGB(30, 30, 30) -- Dark gray tab button
		c.BackgroundTransparency = 1
		c.BorderSizePixel = 0
		c.Position = UDim2.new(0, 0, 1, 0)
		c.Size = UDim2.new(0, 100, 0, 23)
		c.AutoButtonColor = false
		c.Font = Enum.Font.GothamSemibold
		c.Text = "   " .. a
		c.TextColor3 = Color3.fromRGB(200, 200, 200) -- Light gray tab text
		c.TextSize = 12.000
		c.TextXAlignment = Enum.TextXAlignment.Left
		local t = Instance.new("Frame")
		t.Name = "LeftStripe"
		t.Parent = c
		t.BackgroundColor3 = Color3.fromRGB(255, 255, 255) -- White tab stripe
		t.BorderSizePixel = 0
		t.Position = UDim2.new(0, 0, 0.5, -7.5)
		t.Size = UDim2.new(0, 4, 0, 14)
		t.Visible = false
		local u = Instance.new("UICorner")
		u.Name = "ButtonCorner"
		u.CornerRadius = UDim.new(0, 4)
		u.Parent = t
		local a = Instance.new("UICorner")
		a.Name = "ButtonCorner"
		a.CornerRadius = UDim.new(0, 4)
		a.Parent = c
		local a = Instance.new("Frame")
		a.Name = "MainTab"
		a.Parent = l
		a.BackgroundColor3 = Color3.fromRGB(20, 20, 20) -- Black tab content
		a.BorderSizePixel = 0
		a.Position = UDim2.new(0.21, 0, -0.024, 47)
		a.Size = UDim2.new(0, 474, 0, 273)
		a.Visible = false
		local e = Instance.new("UICorner")
		e.Name = "MainTabCorner"
		e.CornerRadius = UDim.new(0, 9)
		e.Parent = a
		local e = Instance.new("ScrollingFrame")
		e.Name = "ScrollTab"
		e.Parent = a
		e.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		e.BackgroundTransparency = 1.000
		e.BorderSizePixel = 0
		e.Position = UDim2.new(0, -1, 0, 0)
		e.Size = UDim2.new(0, 475, 0, 273)
		e.CanvasSize = UDim2.new(0, 0, 0, 0)
		e.ScrollBarThickness = 0
		local h = Instance.new("UIListLayout")
		h.Name = "TabList"
		h.Parent = e
		h.SortOrder = Enum.SortOrder.LayoutOrder
		h.Padding = UDim.new(0, 5)
		local i = Instance.new("UIPadding")
		i.Name = "TabPadding"
		i.Parent = e
		i.PaddingLeft = UDim.new(0, 10)
		i.PaddingTop = UDim.new(0, 10)
		c.MouseButton1Click:Connect(
			function()
				g = a.Name
				for v, w in next, l:GetChildren() do
					if w.Name == "MainTab" then
						w.Visible = false
					end
				end
				for v, x in next, d:GetChildren() do
					if x:IsA("TextButton") then
						local y = x:FindFirstChild("LeftStripe")
						if y then
							y.Visible = false
							y.Size = UDim2.new(0, 4, 0, 0)
						end
					end
				end
				a.Visible = true
				t.Visible = true
				local z =
					s:Create(
						t,
						TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
						{Size = UDim2.new(0, 4, 0, 14)}
					)
				z:Play()
				for v, x in next, d:GetChildren() do
					if x:IsA("TextButton") then
						b:Create(
							x,
							TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
							{BackgroundTransparency = 1}
						):Play()
					end
				end
				b:Create(
					c,
					TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
					{BackgroundTransparency = 0}
				):Play()
			end
		)
		if f == false then
			b:Create(
				c,
				TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
				{BackgroundTransparency = 0}
			):Play()
			for b, b in next, l:GetChildren() do
				if b.Name == "MainTab" then
					b.Visible = false
					t.Visible = false
				end
				a.Visible = true
				t.Visible = true
			end
			f = true
		end
		game:GetService("RunService").Stepped:Connect(
			function()
				pcall(
					function()
						d.CanvasSize = UDim2.new(0, 0, 0, j.AbsoluteContentSize.Y + 10)
						e.CanvasSize = UDim2.new(0, 0, 0, h.AbsoluteContentSize.Y + 30)
					end
				)
			end
		)
		local a = {}
		function a:AddButton(a, c)
			local d = {}
			local f = Instance.new("TextButton")
			f.Name = "Button"
			f.Parent = e
			f.BackgroundColor3 = Color3.fromRGB(30, 30, 30) -- Dark gray button
			f.BackgroundTransparency = 0
			f.BorderSizePixel = 0
			f.Size = UDim2.new(0, 455, 0, 30)
			f.AutoButtonColor = false
			f.Font = Enum.Font.Gotham
			f.Text = a
			f.TextColor3 = Color3.fromRGB(240, 240, 240) -- Light gray button text
			f.TextSize = 11.000
			f.TextWrapped = true
			function d:SetButton(a)
				f.Text = a
			end
			local a = Instance.new("UICorner")
			a.Name = "ButtonCorner"
			a.CornerRadius = UDim.new(0, 4)
			a.Parent = f
			f.MouseEnter:Connect(
				function()
					b:Create(
						f,
						TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
						{TextColor3 = Color3.fromRGB(255, 255, 255)} -- White hover
					):Play()
				end
			)
			f.MouseLeave:Connect(
				function()
					b:Create(
						f,
						TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
						{TextColor3 = Color3.fromRGB(240, 240, 240)} -- Back to light gray
					):Play()
				end
			)
			f.MouseButton1Click:Connect(
				function()
					c()
					f.TextSize = 7
					b:Create(f, TweenInfo.new(0.4, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {TextSize = 11}):Play()
				end
			)
			return d
		end
		function a:AddToggle(a, c, d)
			local f = {}
			local g = Instance.new("Frame")
			local h = Instance.new("TextButton")
			h.Name = "Toggle"
			h.Parent = e
			h.BackgroundColor3 = Color3.fromRGB(30, 30, 30) -- Dark gray toggle
			h.BackgroundTransparency = 0
			h.BorderSizePixel = 0
			h.AutoButtonColor = false
			h.Size = UDim2.new(0, 455, 0, 30)
			h.Font = Enum.Font.SourceSans
			h.Text = ""
			h.TextColor3 = Color3.fromRGB(0, 0, 0)
			h.TextSize = 14.000
			local e = Instance.new("UICorner")
			e.Name = "ToggleCorner"
			e.CornerRadius = UDim.new(0, 4)
			e.Parent = h
			local e = Instance.new("TextLabel")
			e.Name = "ToggleLabel"
			e.Parent = h
			e.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			e.BackgroundTransparency = 1.000
			e.Position = UDim2.new(0, 13, 0, 0)
			e.Size = UDim2.new(0, 410, 0, 30)
			e.Font = Enum.Font.Gotham
			e.Text = a
			e.TextColor3 = Color3.fromRGB(240, 240, 240) -- Light gray toggle text
			e.TextSize = 11.000
			e.TextXAlignment = Enum.TextXAlignment.Left
			function f:SetToggle(a)
				e.Text = a
			end
			g.Name = "ToggleImage"
			g.Parent = h
			g.BackgroundColor3 = Color3.fromRGB(50, 50, 50) -- Dark gray toggle box
			g.Position = UDim2.new(0, 425, 0, 5)
			g.BorderSizePixel = 0
			g.Size = UDim2.new(0, 20, 0, 20)
			local a = Instance.new("UICorner")
			a.Name = "ToggleImageCorner"
			a.CornerRadius = UDim.new(0, 5)
			a.Parent = g
			local a = Instance.new("UIStroke")
			a.Name = "UIStroke"
			a.Parent = g
			a.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			a.Color = Color3.fromRGB(50, 50, 50) -- Dark gray stroke
			a.LineJoinMode = Enum.LineJoinMode.Round
			a.Thickness = 1
			a.Transparency = 0
			a.Enabled = true
			a.Archivable = true
			local a = Instance.new("ImageLabel")
			a.Name = "ToggleImage2"
			a.Parent = g
			a.Image = "rbxassetid://8498709213"
			a.AnchorPoint = Vector2.new(0.5, 0.5)
			a.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			a.Position = UDim2.new(0, 10, 0, 10)
			a.ImageColor3 = Color3.fromRGB(255, 255, 255) -- White checkmark
			a.Visible = false
			a.BackgroundTransparency = 1.000
			local g = Instance.new("UICorner")
			g.Name = "ToggleImageCorner"
			g.CornerRadius = UDim.new(0, 5)
			g.Parent = a
			h.MouseEnter:Connect(
				function()
					b:Create(
						e,
						TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
						{TextColor3 = Color3.fromRGB(255, 255, 255)} -- White hover
					):Play()
				end
			)
			h.MouseLeave:Connect(
				function()
					b:Create(
						e,
						TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
						{TextColor3 = Color3.fromRGB(240, 240, 240)} -- Back to light gray
					):Play()
				end
			)
			if c == nil then
				c = false
			end
			local b = c or false
			h.MouseButton1Click:Connect(
				function()
					if b == false then
						b = true
						a.Visible = true
						a:TweenSize(UDim2.new(0, 26, 0, 26), "In", "Quad", 0.1, true)
					else
						b = false
						a:TweenSize(UDim2.new(0, 0, 0, 0), "In", "Quad", 0.1, true)
						wait(0.1)
						a.Visible = false
					end
					d(b)
				end
			)
			if c == true then
				a.Visible = true
				a:TweenSize(UDim2.new(0, 26, 0, 26), "In", "Quad", 0.1, true)
				b = true
				d(b)
			end
			return f
		end
		function a:AddTextbox(a, b, c)
			local d = {}
			local f = Instance.new("Frame")
			local g = Instance.new("UICorner")
			local h = Instance.new("TextLabel")
			local i = Instance.new("TextBox")
			local j = Instance.new("UICorner")
			f.Name = "Textboxx"
			f.Parent = e
			f.BackgroundColor3 = Color3.fromRGB(30, 30, 30) -- Dark gray textbox
			f.Size = UDim2.new(0, 455, 0, 30)
			g.CornerRadius = UDim.new(0, 4)
			g.Name = "TextboxxCorner"
			g.Parent = f
			h.Name = "TextboxTitle"
			h.Parent = f
			h.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			h.BackgroundTransparency = 1.000
			h.Position = UDim2.new(0, 15, 0, 0)
			h.Size = UDim2.new(0, 300, 0, 30)
			h.Font = Enum.Font.Gotham
			h.Text = a
			h.TextColor3 = Color3.fromRGB(240, 240, 240) -- Light gray title
			h.TextSize = 11.000
			h.TextXAlignment = Enum.TextXAlignment.Left
			function d:SetTextbox(a)
				h.Text = a
			end
			i.Name = "Textbox"
			i.Parent = f
			i.BackgroundColor3 = Color3.fromRGB(30, 30, 30) -- Dark gray input
			i.Position = UDim2.new(0, 310, 0, 5)
			i.Size = UDim2.new(0, 140, 0, 20)
			i.Font = Enum.Font.GothamSemibold
			i.Text = b
			i.TextColor3 = Color3.fromRGB(150, 150, 150) -- Gray placeholder
			i.TextSize = 11.000
			i.TextTruncate = Enum.TextTruncate.AtEnd
			i.ClearTextOnFocus = false
			local A = b
			local a = Instance.new("UIStroke")
			a.Name = "UIStroke"
			a.Parent = i
			a.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			a.Color = Color3.fromRGB(50, 50, 50) -- Dark gray stroke
			a.LineJoinMode = Enum.LineJoinMode.Round
			a.Thickness = 1
			a.Transparency = 0
			a.Enabled = true
			a.Archivable = true
			i.FocusLost:Connect(
				function()
					if #i.Text > 0 then
						c(i.Text)
					else
						i.Text = A
						i.TextColor3 = Color3.fromRGB(150, 150, 150) -- Gray placeholder
					end
				end
			)
			i.Focused:Connect(
				function()
					if i.Text == A then
						i.Text = ""
						i.TextColor3 = Color3.fromRGB(255, 255, 255) -- White input text
					end
				end
			)
			j.Name = "TextboxCorner"
			j.CornerRadius = UDim.new(0, 5)
			j.Parent = i
			return d
		end
		function a:AddDropdown(a, c, d, f)
			local g = Instance.new("Frame")
			local h = Instance.new("UICorner")
			local i = Instance.new("TextButton")
			local j = Instance.new("TextLabel")
			local k = Instance.new("ScrollingFrame")
			local l = Instance.new("UIListLayout")
			local m = Instance.new("UIPadding")
			local n = Instance.new("ImageLabel")
			local B = Instance.new("TextBox")
			local C = Instance.new("UIStroke")
			local D = Instance.new("UICorner")
			local E = {}
			g.Name = "Dropdown"
			g.Parent = e
			g.Active = true
			g.BackgroundColor3 = Color3.fromRGB(30, 30, 30) -- Dark gray dropdown
			g.ClipsDescendants = true
			g.Size = UDim2.new(0, 455, 0, 30)
			h.CornerRadius = UDim.new(0, 4)
			h.Parent = g
			i.Name = "DropButton"
			i.Parent = g
			i.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			i.BackgroundTransparency = 1.000
			i.Size = UDim2.new(0, 455, 0, 30)
			i.Font = Enum.Font.SourceSans
			i.Text = ""
			i.TextColor3 = Color3.fromRGB(0, 0, 0)
			i.TextSize = 14.000
			j.Name = "Droptitle"
			j.Parent = g
			j.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			j.BackgroundTransparency = 1.000
			j.Position = UDim2.new(0.028, 0, 0, 0)
			j.Size = UDim2.new(0, 410, 0, 30)
			j.Font = Enum.Font.Gotham
			j.Text = a .. " : " .. c
			j.TextColor3 = Color3.fromRGB(240, 240, 240) -- Light gray dropdown text
			j.TextSize = 11.000
			j.TextXAlignment = Enum.TextXAlignment.Left
			n.Name = "DropImage"
			n.Parent = g
			n.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			n.BackgroundTransparency = 1.000
			n.Position = UDim2.new(0, 425, 0, 5)
			n.Rotation = 0
			n.Size = UDim2.new(0, 20, 0, 20)
			n.Image = "rbxassetid://5012539403"
			n.ImageColor3 = Color3.fromRGB(255, 255, 255) -- White arrow
			B.Name = "SearchBox"
			B.Parent = g
			B.Size = UDim2.new(0.2, 0, 0, 20)
			B.Position = UDim2.new(0, 330, 0.1, 2)
			B.PlaceholderText = "Search..."
			B.Font = Enum.Font.Gotham
			B.TextSize = 11
			B.TextColor3 = Color3.fromRGB(240, 240, 240) -- Light gray search text
			B.BackgroundColor3 = Color3.fromRGB(30, 30, 30) -- Dark gray search box
			B.Text = ""
			B.AnchorPoint = Vector2.new(0, 0)
			B.AutomaticSize = Enum.AutomaticSize.None
			B.Visible = false
			C.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			C.Color = Color3.fromRGB(50, 50, 50) -- Dark gray stroke
			C.Thickness = 1.2
			C.Parent = B
			D.CornerRadius = UDim.new(0, 4)
			D.Parent = B
			k.Name = "DropScroll"
			k.Parent = g
			k.Active = true
			k.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			k.BackgroundTransparency = 1.000
			k.BorderSizePixel = 0
			k.Position = UDim2.new(0, 0, 0, 30)
			k.Size = UDim2.new(0, 455, 0, 135)
			k.CanvasSize = UDim2.new(0, 0, 0, 2)
			k.ScrollBarThickness = 4
			k.ScrollingDirection = Enum.ScrollingDirection.Y
			k.ScrollBarImageColor3 = Color3.fromRGB(150, 150, 150) -- Gray scrollbar
			k.VerticalScrollBarInset = Enum.ScrollBarInset.ScrollBar
			l.Name = "DropdownList"
			l.Parent = k
			l.SortOrder = Enum.SortOrder.LayoutOrder
			l.Padding = UDim.new(0, 5)
			m.Name = "DropdownPadding"
			m.Parent = k
			m.PaddingTop = UDim.new(0, 5)
			function E:Clear()
				for v, w in ipairs(k:GetChildren()) do
					if w:IsA("TextButton") then
						w:Destroy()
					end
				end
			end
			function E:SetDropdown(F)
				j.Text = a .. " : " .. tostring(F)
			end
			local e = false
			function E:Add(G)
				local H = Instance.new("TextButton")
				H.Name = "DropButton2"
				H.Parent = k
				H.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
				H.BackgroundTransparency = 1.000
				H.Size = UDim2.new(0, 455, 0, 30)
				H.Font = Enum.Font.Gotham
				H.TextColor3 = Color3.fromRGB(240, 240, 240) -- Light gray option text
				H.TextSize = 11.000
				H.Text = tostring(G)
				H.MouseEnter:Connect(
					function()
						b:Create(
							H,
							TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
							{TextColor3 = Color3.fromRGB(255, 255, 255)} -- White hover
						):Play()
					end
				)
				H.MouseLeave:Connect(
					function()
						b:Create(
							H,
							TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
							{TextColor3 = Color3.fromRGB(240, 240, 240)} -- Back to light gray
						):Play()
					end
				)
				H.MouseButton1Click:Connect(
					function()
						self:SetDropdown(G)
						f(G)
						e = not e
						B.Text = ""
						B.Visible = false
						B.Position = UDim2.new(0, 330, 0.1, 2)
						b:Create(
							g,
							TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
							{Size = UDim2.new(0, 455, 0, 30)}
						):Play()
						b:Create(n, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Rotation = 0}):Play()
					end
				)
			end
			i.MouseButton1Click:Connect(
				function()
					e = not e
					if e then
						B.Visible = true
						B.Position = UDim2.new(0, 330, 0.1, -12)
						b:Create(
							g,
							TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
							{Size = UDim2.new(0, 455, 0, 180)}
						):Play()
						b:Create(
							n,
							TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
							{Rotation = -180}
						):Play()
						k.CanvasSize = UDim2.new(0, 0, 0, l.AbsoluteContentSize.Y + 10)
					else
						B.Text = ""
						B.Visible = false
						B.Position = UDim2.new(0, 330, 0.1, 2)
						b:Create(
							g,
							TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
							{Size = UDim2.new(0, 455, 0, 30)}
						):Play()
						b:Create(n, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Rotation = 0}):Play()
					end
				end
			)
			B:GetPropertyChangedSignal("Text"):Connect(
				function()
					local I = string.lower(B.Text)
					for v, w in ipairs(k:GetChildren()) do
						if w:IsA("TextButton") then
							w.Visible = string.find(string.lower(w.Text), I) ~= nil
						end
					end
					k.CanvasSize = UDim2.new(0, 0, 0, l.AbsoluteContentSize.Y + 10)
				end
			)
			for v, F in ipairs(d) do
				E:Add(F)
			end
			return E
		end
		function a:AddSlider(a, b, c, d, f)
			local g = {}
			d = math.clamp(d, b, c)
			local h = Instance.new("Frame")
			local i = Instance.new("UICorner")
			local j = Instance.new("TextLabel")
			local k = Instance.new("TextLabel")
			local l = Instance.new("TextButton")
			local m = Instance.new("Frame")
			local n = Instance.new("Frame")
			local o = Instance.new("UICorner")
			local p = Instance.new("Frame")
			local q = Instance.new("UICorner")
			local r = Instance.new("UICorner")
			local J = Instance.new("UIStroke")
			h.Name = "Slider"
			h.Parent = e
			h.BackgroundColor3 = Color3.fromRGB(30, 30, 30) -- Dark gray slider
			h.Size = UDim2.new(0, 455, 0, 40)
			i.CornerRadius = UDim.new(0, 4)
			i.Parent = h
			j.Name = "SliderTitle"
			j.Parent = h
			j.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			j.BackgroundTransparency = 1.000
			j.Position = UDim2.new(0.028, 0, 0, 0)
			j.Size = UDim2.new(0, 290, 0, 20)
			j.Font = Enum.Font.Gotham
			j.Text = a
			j.TextColor3 = Color3.fromRGB(240, 240, 240) -- Light gray title
			j.TextSize = 11.000
			j.TextXAlignment = Enum.TextXAlignment.Left
			k.Name = "SliderValue"
			k.Parent = h
			k.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			k.BackgroundTransparency = 1.000
			k.Position = UDim2.new(0.88, 0, 0, 0)
			k.Size = UDim2.new(0, 40, 0, 20)
			k.Font = Enum.Font.Gotham
			k.Text = tostring(d)
			k.TextColor3 = Color3.fromRGB(240, 240, 240) -- Light gray value
			k.TextSize = 11.000
			l.Name = "SliderButton"
			l.Parent = h
			l.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			l.BackgroundTransparency = 1.000
			l.Position = UDim2.new(0, 10, 0, 25)
			l.Size = UDim2.new(0, 435, 0, 5)
			l.AutoButtonColor = false
			l.Font = Enum.Font.SourceSans
			l.Text = ""
			l.TextSize = 14.000
			m.Name = "Bar1"
			m.Parent = l
			m.BackgroundColor3 = Color3.fromRGB(50, 50, 50) -- Dark gray bar
			m.Size = UDim2.new(1, 0, 0, 5)
			J.Parent = m
			J.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			J.Color = Color3.fromRGB(50, 50, 50) -- Dark gray stroke
			J.LineJoinMode = Enum.LineJoinMode.Round
			J.Thickness = 1
			o.CornerRadius = UDim.new(0, 100)
			o.Parent = m
			n.Name = "Bar"
			n.Parent = m
			n.BackgroundColor3 = Color3.fromRGB(255, 255, 255) -- White fill
			n.Size = UDim2.new((d - b) / (c - b), 0, 1, 0)
			o.CornerRadius = UDim.new(0, 100)
			o.Parent = n
			p.Name = "CircleBar"
			p.Parent = n
			p.BackgroundColor3 = Color3.fromRGB(255, 255, 255) -- White circle
			p.AnchorPoint = Vector2.new(0.5, 0.5)
			p.Position = UDim2.new(1, 0, 0.5, 0)
			p.Size = UDim2.new(0, 10, 0, 10)
			q.CornerRadius = UDim.new(0, 100)
			q.Parent = p
			r.CornerRadius = UDim.new(0, 100)
			r.Parent = m
			local K = game.Players.LocalPlayer:GetMouse()
			local L = game:GetService("UserInputService")
			local M = false
			l.MouseButton1Down:Connect(
				function()
					M = true
				end
			)
			L.InputEnded:Connect(
				function(N)
					if N.UserInputType == Enum.UserInputType.MouseButton1 then
						M = false
					end
				end
			)
			L.InputChanged:Connect(
				function(N)
					if M and N.UserInputType == Enum.UserInputType.MouseMovement then
						local O = math.clamp(K.X - m.AbsolutePosition.X, 0, m.AbsoluteSize.X)
						local P = math.floor(O / m.AbsoluteSize.X * (c - b) + b)
						n.Size = UDim2.new(O / m.AbsoluteSize.X, 0, 1, 0)
						p.Position = UDim2.new(1, 0, 0.5, 0)
						k.Text = tostring(P)
						pcall(
							function()
								f(P)
							end
						)
					end
				end
			)
			return g
		end
		function a:AddSeperator(a)
			local b = {}
			local c = Instance.new("Frame")
			local d = Instance.new("TextLabel")
			c.Name = "Seperator"
			c.Parent = e
			c.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			c.BackgroundTransparency = 1.000
			c.ClipsDescendants = true
			c.Size = UDim2.new(0, 455, 0, 20)
			local e = Instance.new("UICorner")
			e.Name = "MainCorner"
			e.CornerRadius = UDim.new(0, 9)
			e.Parent = c
			local e = Instance.new("UICorner")
			e.Name = "MainCorner"
			e.CornerRadius = UDim.new(0, 9)
			e.Parent = Sep1
			d.Name = "SepLabel"
			d.Parent = c
			d.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			d.BackgroundTransparency = 1.000
			d.Position = UDim2.new(0, 5, 0, 0)
			d.Size = UDim2.new(0, 255, 0, 20)
			d.Font = Enum.Font.GothamSemibold
			d.Text = a
			d.TextColor3 = Color3.fromRGB(91, 91, 91)
			d.TextXAlignment = Enum.TextXAlignment.Left
			d.TextSize = 12.000
			function b:SetSep(a)
				d.Text = a
			end
			return b
		end
		function a:AddLine()
			local a = Instance.new("Frame")
			local b = Instance.new("Frame")
			a.Name = "Line"
			a.Parent = e
			a.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			a.BackgroundTransparency = 1.000
			a.ClipsDescendants = true
			a.Size = UDim2.new(0, 455, 0, 20)
			b.Name = "Linee"
			b.Parent = a
			b.BackgroundColor3 = Color3.fromRGB(150, 150, 150) -- Gray line
			b.BorderSizePixel = 0
			b.Position = UDim2.new(0, 0, 0, 10)
			b.Size = UDim2.new(0, 455, 0, 2)
		end
		function a:AddNLabel(a)
			local b = Instance.new("TextLabel")
			local c = Instance.new("UIPadding")
			local d = {}
			b.Name = "Label"
			b.Parent = e
			b.BackgroundColor3 = Color3.fromRGB(30, 30, 30) -- Dark gray label
			b.BackgroundTransparency = 0
			b.Size = UDim2.new(0, 455, 0, 57)
			b.Font = Enum.Font.GothamSemibold
			b.TextColor3 = Color3.fromRGB(240, 240, 240) -- Light gray text
			b.TextSize = 11.000
			b.Text = a
			b.TextXAlignment = Enum.TextXAlignment.Left
			c.PaddingLeft = UDim.new(0, 10)
			c.Parent = b
			c.Name = "PaddingLabel"
			local a = Instance.new("UICorner")
			a.Name = "MainCorner"
			a.CornerRadius = UDim.new(0, 5)
			a.Parent = b
			local a = Instance.new("ImageLabel")
			a.Parent = b
			a.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			a.BorderColor3 = Color3.fromRGB(0, 0, 0)
			a.BackgroundTransparency = 1.000
			a.BorderSizePixel = 0
			a.Position = UDim2.new(0.851666677, 0, -0.1, 0)
			a.Size = UDim2.new(0, 60, 0, 60)
			a.Image =
				"https://www.roblox.com/headshot-thumbnail/image?userId=" ..
				game.Players.LocalPlayer.UserId .. "&width=420&height=420&format=png"
			function d:Set2(a)
				b.Text = a
			end
			return d
		end
		function a:AddLabel(a, b)
			local c = Instance.new("Frame")
			c.Name = "Mainl"
			c.Parent = e
			c.BackgroundColor3 = Color3.fromRGB(30, 30, 30) -- Dark gray label
			c.BackgroundTransparency = 0
			c.BorderSizePixel = 0
			c.Size = UDim2.new(0, 455, 0, 35)
			local d = Instance.new("TextLabel")
			local e = Instance.new("UIPadding")
			local f = {}
			d.Name = "Title"
			d.Parent = c
			d.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
			d.BackgroundTransparency = 1
			d.Size = UDim2.new(0, 455, 0, 35)
			d.Font = Enum.Font.GothamBold
			d.TextColor3 = Color3.fromRGB(240, 240, 240) -- Light gray title
			d.TextSize = 11.000
			d.Position = UDim2.new(-0.009, 0, -0.2, 0)
			d.Text = a
			d.TextXAlignment = Enum.TextXAlignment.Left
			local a = Instance.new("TextLabel")
			a.Name = "Text"
			a.Parent = c
			a.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
			a.BackgroundTransparency = 1
			a.Size = UDim2.new(0, 455, 0, 35)
			a.Font = Enum.Font.Gotham
			a.TextColor3 = Color3.fromRGB(200, 200, 200) -- Slightly darker gray subtitle
			a.TextSize = 11.000
			a.Position = UDim2.new(0.014, 0, 0.18, 0)
			a.Text = b
			a.TextXAlignment = Enum.TextXAlignment.Left
			e.PaddingLeft = UDim.new(0, 10)
			e.Parent = d
			e.Name = "PaddingLabel"
			local b = Instance.new("UICorner")
			b.Name = "MainCorner"
			b.CornerRadius = UDim.new(0, 4)
			b.Parent = c
			function f:Set(b)
				a.Text = b
			end
			return f
		end
		return a
	end
	return a
end
local window = d:AddWindow("internal.lua", Enum.KeyCode.RightControl)
-- Services & Globals (unchanged)
repeat
	task.wait();
until game:IsLoaded() 
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local Debris = game:GetService("Debris")
local VirtualInputManager = game:GetService("VirtualInputManager")
local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:FindFirstChildOfClass("Humanoid")

local Alive = Workspace:FindFirstChild("Alive")
local Aerodynamic = false
local Aerodynamic_Time = tick()
local Last_Input = UserInputService:GetLastInputType()
local Vector2_Mouse_Location = nil
local Grab_Parry = nil
local Parry_Key = nil
local Remotes = {}
local revertedRemotes = {}
local originalMetatables = {}
local Parries = 0
local Connections_Manager = {}
local Animation = {storage = {}, current = nil, track = nil}

setfpscap(60)


local function isValidRemoteArgs(args)
    return #args == 7 and
           type(args[2]) == "string" and  
           type(args[3]) == "number" and 
           typeof(args[4]) == "CFrame" and 
           type(args[5]) == "table" and  
           type(args[6]) == "table" and 
           type(args[7]) == "boolean"
end
local function hookRemote(remote)
    if not revertedRemotes[remote] then
        if not originalMetatables[getmetatable(remote)] then
            originalMetatables[getmetatable(remote)] = true

            local meta = getrawmetatable(remote)
            setreadonly(meta, false)

            local oldIndex = meta.__index
            meta.__index = function(self, key)
                if (key == "FireServer" and self:IsA("RemoteEvent")) or (key == "InvokeServer" and self:IsA("RemoteFunction")) then
                    return function(_, ...)
                        local args = {...}
                        if isValidRemoteArgs(args) then
                            if not revertedRemotes[self] then
                                revertedRemotes[self] = args
                                
                                -- Copy remote name + args to clipboard
                                local remoteType = self:IsA("RemoteEvent") and "RemoteEvent" or "RemoteFunction"
                                local remoteData = {
                                    RemoteName = self.Name,
                                    RemoteType = remoteType,
                                    Args = args
                                }
                                setclipboard(game:GetService("HttpService"):JSONEncode(remoteData))
                                
                                print("â Remote copied to clipboard!")
                                game.StarterGui:SetCore("SendNotification", {
                                    Title = "vhub",
                                    Text = "auto parry loaded",
                                    Duration = 5,
                                })
                            end
                        end
                        return oldIndex(self, key)(_, unpack(args))
                    end
                end
                return oldIndex(self, key)
            end

            setreadonly(meta, true)
        end
    end
end

local function restoreRemotes()
    for remote, _ in pairs(revertedRemotes) do
        if originalMetatables[getmetatable(remote)] then
            local meta = getrawmetatable(remote)
            setreadonly(meta, false)
            meta.__index = nil  -- Reset metatable behavior
            setreadonly(meta, true)
        end
    end
    revertedRemotes = {}  -- Clear captured remotes
    print("Remotes restored.")
end

for _, remote in pairs(game.ReplicatedStorage:GetChildren()) do
    if remote:IsA("RemoteEvent") or remote:IsA("RemoteFunction") then
        hookRemote(remote)
    end
end

game.ReplicatedStorage.ChildAdded:Connect(function(child)
    if child:IsA("RemoteEvent") or child:IsA("RemoteFunction") then
        hookRemote(child)
    end
end)

local function createAnimation(object, info, value)
	local animation = TweenService:Create(object, info, value);
	animation:Play();
	task.wait(info.Time);
	Debris:AddItem(animation, 0);
	animation:Destroy();
end
for _, animation in pairs(ReplicatedStorage.Misc.Emotes:GetChildren()) do
	if (animation:IsA("Animation") and animation:GetAttribute("EmoteName")) then
		local emoteName = animation:GetAttribute("EmoteName");
		Animation.storage[emoteName] = animation;
	end
end

local Key = Parry_Key;
local Auto_Parry = {};
Auto_Parry.Parry_Animation = function()
	local Parry_Animation = ReplicatedStorage.Shared.SwordAPI.Collection.Default:FindFirstChild("GrabParry");
	local Current_Sword = LocalPlayer.Character:GetAttribute("CurrentlyEquippedSword");
	if (not Current_Sword or not Parry_Animation) then
		return;
	end
	local Sword_Data = ReplicatedStorage.Shared.ReplicatedInstances.Swords.GetSword:Invoke(Current_Sword);
	if (not Sword_Data or not Sword_Data['AnimationType']) then
		return;
	end
	for _, object in pairs(ReplicatedStorage.Shared.SwordAPI.Collection:GetChildren()) do
		if (object.Name == Sword_Data['AnimationType']) then
			local sword_animation_type = (object:FindFirstChild("GrabParry") and "GrabParry") or "Grab";
			Parry_Animation = object[sword_animation_type];
		end
	end
	Grab_Parry = LocalPlayer.Character.Humanoid.Animator:LoadAnimation(Parry_Animation);
	Grab_Parry:Play();
end;
Auto_Parry.Play_Animation = function(animationName)
	local Animations = Animation.storage[animationName];
	if not Animations then
		return false;
	end
	local Animator = LocalPlayer.Character.Humanoid.Animator;
	if (Animation.track and Animation.track:IsA("AnimationTrack")) then
		Animation.track:Stop();
	end
	Animation.track = Animator:LoadAnimation(Animations);
	if (Animation.track and Animation.track:IsA("AnimationTrack")) then
		Animation.track:Play();
	end
	Animation.current = animationName;
end;
Auto_Parry.Get_Balls = function()
	local Balls = {};
	for _, instance in pairs(Workspace.Balls:GetChildren()) do
		if instance:GetAttribute("realBall") then
			instance.CanCollide = false;
			table.insert(Balls, instance);
		end
	end
	return Balls;
end;
Auto_Parry.Get_Ball = function()
	for _, instance in pairs(Workspace.Balls:GetChildren()) do
		if instance:GetAttribute("realBall") then
			instance.CanCollide = false;
			return instance;
		end
	end
end;
Auto_Parry.Parry_Data = function()
	local Events = {};
	local Camera = workspace.CurrentCamera;
	if ((Last_Input == Enum.UserInputType.MouseButton1) or (Last_Input == Enum.UserInputType.MouseButton2) or (Last_Input == Enum.UserInputType.Keyboard)) then
		local Mouse_Location = UserInputService:GetMouseLocation();
		Vector2_Mouse_Location = {Mouse_Location.X,Mouse_Location.Y};
	else
		Vector2_Mouse_Location = {(Camera.ViewportSize.X / 2),(Camera.ViewportSize.Y / 2)};
	end
	for _, v in pairs(workspace.Alive:GetChildren()) do
		if (v:IsA("Model") and v.PrimaryPart) then
			Events[tostring(v)] = Camera:WorldToScreenPoint(v.PrimaryPart.Position);
		end
	end
	return {0,Camera.CFrame,Events,Vector2_Mouse_Location};
end;
local Parry_Method = "Remote"
local FirstParryDone = false 

function Auto_Parry.Parry(Parry_Type)  -- Correct way #1
    local Parry_Data = Auto_Parry.Parry_Data(Parry_Type)
    
    if not FirstParryDone then
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.F, false, game)
        task.wait(0.1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.F, false, game)
        FirstParryDone = true 
    else
        for remote, args in pairs(revertedRemotes) do
            if remote:IsA("RemoteEvent") then
                remote:FireServer(unpack(args))
            elseif remote:IsA("RemoteFunction") then
                remote:InvokeServer(unpack(args))
            end
        end
    end

    if Parries > 7 then
        return false
    end

    Parries += 1

    task.delay(0.5, function()
        if Parries > 0 then
            Parries -= 1
        end
    end)
end
local Lerp_Radians = 0;
local Last_Warping = tick();
Auto_Parry.Linear_Interpolation = function(a, b, time_volume)
	return a + ((b - a) * time_volume);
end;
local Previous_Velocity = {};
local Curving = tick();
Auto_Parry.Is_Curved = function()
	local Ball = Auto_Parry.Get_Ball();
	if not Ball then
		return false;
	end
	local Zoomies = Ball:FindFirstChild("zoomies");
	if not Zoomies then
		return false;
	end
	local Ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue();
	local Velocity = Zoomies.VectorVelocity;
	local Ball_Direction = Velocity.Unit;
	local Direction = (LocalPlayer.Character.PrimaryPart.Position - Ball.Position).Unit;
	local Dot = Direction:Dot(Ball_Direction);
	local Speed = Velocity.Magnitude;
	local Speed_Threshold = math.min(Speed / 100, 40);
	local Angle_Threshold = 40 * math.max(Dot, 0);
	local Direction_Difference = (Ball_Direction - Velocity).Unit;
	local Direction_Similarity = Direction:Dot(Direction_Difference);
	local Dot_Difference = Dot - Direction_Similarity;
	local Dot_Threshold = 0.5 - (Ping / 1000);
	local Distance = (LocalPlayer.Character.PrimaryPart.Position - Ball.Position).Magnitude;
	local Reach_Time = (Distance / Speed) - (Ping / 1000);
	local Enough_Speed = Speed > 100;
	local Ball_Distance_Threshold = (15 - math.min(Distance / 1000, 15)) + Angle_Threshold + Speed_Threshold;
	table.insert(Previous_Velocity, Velocity);
	if (#Previous_Velocity > 4) then
		table.remove(Previous_Velocity, 1);
	end
	if (Enough_Speed and (Reach_Time > (Ping / 10))) then
		Ball_Distance_Threshold = math.max(Ball_Distance_Threshold - 15, 15);
	end
	if (Distance < Ball_Distance_Threshold) then
		return false;
	end
	if ((tick() - Curving) < (Reach_Time / 1.5)) then
		return true;
	end
	if (Dot_Difference < Dot_Threshold) then
		return true;
	end
	local Radians = math.asin(Dot);
	Lerp_Radians = Auto_Parry.Linear_Interpolation(Lerp_Radians, Radians, 0.8);
	if (Lerp_Radians < 0.018) then
		Last_Warping = tick();
	end
	if ((tick() - Last_Warping) < (Reach_Time / 1.5)) then
		return true;
	end
	if (#Previous_Velocity == 4) then
		for i = 1, 2 do
			local Intended_Direction_Difference = (Ball_Direction - Previous_Velocity[i].Unit).Unit;
			local Intended_Dot = Direction:Dot(Intended_Direction_Difference);
			local Intended_Dot_Difference = Dot - Intended_Dot;
			if (Intended_Dot_Difference < Dot_Threshold) then
				return true;
			end
		end
	end
	return Dot < Dot_Threshold;
end;
Auto_Parry.Closest_Player = function()
	local Max_Distance = math.huge;
	Closest_Entity = nil;
	for _, Entity in pairs(Workspace.Alive:GetChildren()) do
		if ((tostring(Entity) ~= tostring(LocalPlayer)) and Entity.PrimaryPart) then
			local Distance = LocalPlayer:DistanceFromCharacter(Entity.PrimaryPart.Position);
			if (Distance < Max_Distance) then
				Max_Distance = Distance;
				Closest_Entity = Entity;
			end
		end
	end
	return Closest_Entity;
end;
Auto_Parry.Get_Entity_Properties = function(self)
	Auto_Parry.Closest_Player();
	if not Closest_Entity then
		return false;
	end
	local Entity_Velocity = Closest_Entity.PrimaryPart.Velocity;
	local Entity_Direction = (LocalPlayer.Character.PrimaryPart.Position - Closest_Entity.PrimaryPart.Position).Unit;
	local Entity_Distance = (LocalPlayer.Character.PrimaryPart.Position - Closest_Entity.PrimaryPart.Position).Magnitude;
	return {Velocity=Entity_Velocity,Direction=Entity_Direction,Distance=Entity_Distance};
end;
Auto_Parry.Get_Entity_Properties = function(self)
	Auto_Parry.Closest_Player();
	if not Closest_Entity then
		return false;
	end
	local entityVelocity = Closest_Entity.PrimaryPart.Velocity;
	local entityDirection = (LocalPlayer.Character.PrimaryPart.Position - Closest_Entity.PrimaryPart.Position).Unit;
	local entityDistance = (LocalPlayer.Character.PrimaryPart.Position - Closest_Entity.PrimaryPart.Position).Magnitude;
	return {Velocity=entityVelocity,Direction=entityDirection,Distance=entityDistance};
end;
Auto_Parry.Get_Ball_Properties = function(self)
	local ball = Auto_Parry.Get_Ball();
	if not ball then
		return false;
	end
	local character = LocalPlayer.Character;
	if (not character or not character.PrimaryPart) then
		return false;
	end
	local ballVelocity = ball.AssemblyLinearVelocity;
	local ballDirection = (character.PrimaryPart.Position - ball.Position).Unit;
	local ballDistance = (character.PrimaryPart.Position - ball.Position).Magnitude;
	local ballDot = ballDirection:Dot(ballVelocity.Unit);
	return {Velocity=ballVelocity,Direction=ballDirection,Distance=ballDistance,Dot=ballDot};
end;
Auto_Parry.Spam_Service = function(self)
	local ball = Auto_Parry.Get_Ball();
	if not ball then
		return false;
	end
	Auto_Parry.Closest_Player();
	local spamDelay = 0;
	local spamAccuracy = 100;
	if not self.Spam_Sensitivity then
		self.Spam_Sensitivity = 50;
	end
	if not self.Ping_Based_Spam then
		self.Ping_Based_Spam = false;
	end
	local velocity = ball.AssemblyLinearVelocity;
	local speed = velocity.Magnitude;
	local direction = (LocalPlayer.Character.PrimaryPart.Position - ball.Position).Unit;
	local dot = direction:Dot(velocity.Unit);
	local targetPosition = Closest_Entity.PrimaryPart.Position;
	local targetDistance = LocalPlayer:DistanceFromCharacter(targetPosition);
	local maximumSpamDistance = self.Ping + math.min(speed / 6.5, 95);
	maximumSpamDistance = maximumSpamDistance * self.Spam_Sensitivity;
	if self.Ping_Based_Spam then
		maximumSpamDistance = maximumSpamDistance + self.Ping;
	end
	if ((self.Entity_Properties.Distance > maximumSpamDistance) or (self.Ball_Properties.Distance > maximumSpamDistance) or (targetDistance > maximumSpamDistance)) then
		return spamAccuracy;
	end
	local maximumSpeed = 5 - math.min(speed / 5, 5);
	local maximumDot = math.clamp(dot, -1, 0) * maximumSpeed;
	spamAccuracy = maximumSpamDistance - maximumDot;
	task.wait(spamDelay);
	return spamAccuracy;
end;
local visualizerEnabled = false;
local function get_character()
	return LocalPlayer and LocalPlayer.Character;
end
local function get_primary_part()
	local char = get_character();
	return char and char.PrimaryPart;
end
local function get_ball()
	local ballContainer = Workspace:FindFirstChild("Balls");
	if ballContainer then
		for _, ball in ipairs(ballContainer:GetChildren()) do
			if not ball.Anchored then
				return ball;
			end
		end
	end
	return nil;
end
local function calculate_visualizer_radius()
	local ball = get_ball();
	if ball then
		local velocity = ball.Velocity.Magnitude;
		return math.clamp((velocity / 2.4) + 10, 15, 200);
	end
	return 15;
end
local visualizer = Instance.new("Part");
visualizer.Shape = Enum.PartType.Ball;
visualizer.Anchored = true;
visualizer.CanCollide = false;
visualizer.Material = Enum.Material.ForceField;
visualizer.Transparency = 0.5;
visualizer.Parent = Workspace;
visualizer.Size = Vector3.new(0, 0, 0);
local function toggle_visualizer(state)
	visualizerEnabled = state;
	if not state then
		visualizer.Size = Vector3.new(0, 0, 0);
	end
end
RunService.RenderStepped:Connect(function()
	if not visualizerEnabled then
		return;
	end
	local primaryPart = get_primary_part();
	local ball = get_ball();
	if (primaryPart and ball) then
		local radius = calculate_visualizer_radius();
		local isHighlighted = primaryPart:FindFirstChild("Highlight");
		visualizer.Size = Vector3.new(radius, radius, radius);
		visualizer.CFrame = primaryPart.CFrame;
		visualizer.Color = isHighlighted and Color3.fromRGB(255, 255, 255);
	else
		visualizer.Size = Vector3.new(0, 0, 0);
	end
end);


function ManualSpam()

    if MauaulSpam then
        MauaulSpam:Destroy()
        MauaulSpam = nil
        return
    end


    MauaulSpam = Instance.new("ScreenGui")
    MauaulSpam.Name = "MauaulSpam"
    MauaulSpam.Parent = game:GetService("CoreGui") or game.Players.LocalPlayer:WaitForChild("PlayerGui")
    MauaulSpam.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    MauaulSpam.ResetOnSpawn = false


    local Main = Instance.new("Frame")
    Main.Name = "Main"
    Main.Parent = MauaulSpam
    Main.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    Main.BorderColor3 = Color3.fromRGB(0, 0, 0)
    Main.BorderSizePixel = 0
    Main.Position = UDim2.new(0.41414836, 0, 0.404336721, 0)
    Main.Size = UDim2.new(0.227479532, 0, 0.191326529, 0)

    local UICorner = Instance.new("UICorner")
    UICorner.Parent = Main


    local IndercantorBlahblah = Instance.new("Frame")
    IndercantorBlahblah.Name = "IndercantorBlahblah"
    IndercantorBlahblah.Parent = Main
    IndercantorBlahblah.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    IndercantorBlahblah.BorderColor3 = Color3.fromRGB(0, 0, 0)
    IndercantorBlahblah.BorderSizePixel = 0
    IndercantorBlahblah.Position = UDim2.new(0.0280000009, 0, 0.0733333305, 0)
    IndercantorBlahblah.Size = UDim2.new(0.0719999969, 0, 0.119999997, 0)

    local UICorner_2 = Instance.new("UICorner")
    UICorner_2.CornerRadius = UDim.new(1, 0)
    UICorner_2.Parent = IndercantorBlahblah

    local UIAspectRatioConstraint = Instance.new("UIAspectRatioConstraint")
    UIAspectRatioConstraint.Parent = IndercantorBlahblah


    local PC = Instance.new("TextLabel")
    PC.Name = "PC"
    PC.Parent = Main
    PC.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    PC.BackgroundTransparency = 1
    PC.BorderColor3 = Color3.fromRGB(0, 0, 0)
    PC.BorderSizePixel = 0
    PC.Position = UDim2.new(0.547999978, 0, 0.826666653, 0)
    PC.Size = UDim2.new(0.451999992, 0, 0.173333332, 0)
    PC.Font = Enum.Font.Unknown
    PC.Text = "PC: E to spam"
    PC.TextColor3 = Color3.fromRGB(57, 57, 57)
    PC.TextScaled = true
    PC.TextSize = 16
    PC.TextWrapped = true

    local UITextSizeConstraint = Instance.new("UITextSizeConstraint")
    UITextSizeConstraint.Parent = PC
    UITextSizeConstraint.MaxTextSize = 16

    local UIAspectRatioConstraint_2 = Instance.new("UIAspectRatioConstraint")
    UIAspectRatioConstraint_2.Parent = PC
    UIAspectRatioConstraint_2.AspectRatio = 4.346


    local IndercanotTextBlah = Instance.new("TextButton")
    IndercanotTextBlah.Name = "IndercanotTextBlah"
    IndercanotTextBlah.Parent = Main
    IndercanotTextBlah.Active = false
    IndercanotTextBlah.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    IndercanotTextBlah.BackgroundTransparency = 1
    IndercanotTextBlah.BorderColor3 = Color3.fromRGB(0, 0, 0)
    IndercanotTextBlah.BorderSizePixel = 0
    IndercanotTextBlah.Position = UDim2.new(0.164000005, 0, 0.326666653, 0)
    IndercanotTextBlah.Selectable = false
    IndercanotTextBlah.Size = UDim2.new(0.667999983, 0, 0.346666664, 0)
    IndercanotTextBlah.Font = Enum.Font.GothamBold
    IndercanotTextBlah.Text = "Spam"
    IndercanotTextBlah.TextColor3 = Color3.fromRGB(255, 255, 255)
    IndercanotTextBlah.TextScaled = true
    IndercanotTextBlah.TextSize = 24
    IndercanotTextBlah.TextWrapped = true

    local UIGradient = Instance.new("UIGradient")
    UIGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 0, 0)),
        ColorSequenceKeypoint.new(0.75, Color3.fromRGB(255, 0, 4)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 0, 0))
    })
    UIGradient.Parent = IndercanotTextBlah

    local UITextSizeConstraint_2 = Instance.new("UITextSizeConstraint")
    UITextSizeConstraint_2.Parent = IndercanotTextBlah
    UITextSizeConstraint_2.MaxTextSize = 52

    local UIAspectRatioConstraint_3 = Instance.new("UIAspectRatioConstraint")
    UIAspectRatioConstraint_3.Parent = IndercanotTextBlah
    UIAspectRatioConstraint_3.AspectRatio = 3.212

    local UIAspectRatioConstraint_4 = Instance.new("UIAspectRatioConstraint")
    UIAspectRatioConstraint_4.Parent = Main
    UIAspectRatioConstraint_4.AspectRatio = 1.667


    local spamConnection
    local toggleManualSpam = false
    local manualSpamSpeed = 15
    local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")

    local function toggleSpam()
        toggleManualSpam = not toggleManualSpam

        if spamConnection then
            spamConnection:Disconnect()
            spamConnection = nil
        end

        if toggleManualSpam then
            spamConnection = RunService.PreSimulation:Connect(function()
                for _ = 1, manualSpamSpeed do
                    if not toggleManualSpam then
                        break
                    end
                    local success, err = pcall(function()
                        Auto_Parry.Parry()
                    end)
                    if not success then
                        warn("Error in Auto_Parry.Parry:", err)
                    end
                    task.wait()
                end
            end)
        end
    end


    local button = IndercanotTextBlah
    local UIGredient = button.UIGradient
    local NeedToChange = IndercantorBlahblah

    local green_Color = {
        ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 0, 0)),
        ColorSequenceKeypoint.new(0.75, Color3.fromRGB(0, 255, 0)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 0, 0))
    }

    local red_Color = {
        ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 0, 0)),
        ColorSequenceKeypoint.new(0.75, Color3.fromRGB(255, 0, 0)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 0, 0))
    }

    local current_Color = red_Color
    local target_Color = green_Color
    local is_Green = false
    local transition = false
    local transition_Time = 1
    local start_Time

    local function startColorTransition()
        transition = true
        start_Time = tick()
    end

    RunService.Heartbeat:Connect(function()
        if transition then
            local elapsed = tick() - start_Time
            local alpha = math.clamp(elapsed / transition_Time, 0, 1)
            local new_Color = {}

            for i = 1, #current_Color do
                local start_Color = current_Color[i].Value
                local end_Color = target_Color[i].Value
                new_Color[i] = ColorSequenceKeypoint.new(current_Color[i].Time, start_Color:Lerp(end_Color, alpha))
            end

            UIGredient.Color = ColorSequence.new(new_Color)

            if alpha >= 1 then
                transition = false
                current_Color, target_Color = target_Color, current_Color
            end
        end
    end)

    local function toggleColor()
        if not transition then
            is_Green = not is_Green

            if is_Green then
                target_Color = green_Color
                NeedToChange.BackgroundColor3 = Color3.new(0, 1, 0)
                toggleSpam()
            else
                target_Color = red_Color
                NeedToChange.BackgroundColor3 = Color3.new(1, 0, 0)
                toggleSpam()
            end

            startColorTransition()
        end
    end

    button.MouseButton1Click:Connect(toggleColor)


    local keyConnection
    keyConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.KeyCode == Enum.KeyCode.E then
            toggleColor()
        end
    end)


    MauaulSpam.Destroying:Connect(function()
        if keyConnection then
            keyConnection:Disconnect()
        end
        if spamConnection then
            spamConnection:Disconnect()
        end
    end)


    local gui = Main
    local dragging
    local dragInput
    local dragStart
    local startPos

    local function update(input)
        local delta = input.Position - dragStart
        local newPosition = UDim2.new(
            startPos.X.Scale,
            startPos.X.Offset + delta.X,
            startPos.Y.Scale,
            startPos.Y.Offset + delta.Y
        )

        local TweenService = game:GetService("TweenService")
        local tweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local tween = TweenService:Create(gui, tweenInfo, {Position = newPosition})
        tween:Play()
    end

    gui.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or
           input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = gui.Position

            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    gui.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or
           input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if dragging and input == dragInput then
            update(input)
        end
    end)
end

ManualSpam()

--------- ui-----------------------------
-- Create Tabs
local MainTab = window:AddTab("Main")

-- ==================== MAIN TAB ====================
-- ==================== BLADE BALL / PARRY TOGGLES (Exact same style) ====================

local AutoParryEnabled = false
MainTab:AddToggle("Auto Parry", AutoParryEnabled, function(state)
    AutoParryEnabled = state

    if state then
        Connections_Manager["Auto Parry"] = game:GetService("RunService").PreSimulation:Connect(function()
            local Balls = Auto_Parry.Get_Balls()
            if not Balls or #Balls == 0 then return end

            for _, Ball in pairs(Balls) do
                if not Ball then continue end
                local Zoomies = Ball:FindFirstChild("zoomies")
                if not Zoomies then continue end

                if Parried then continue end
                if Ball:GetAttribute("target") ~= tostring(LocalPlayer) then continue end

                local Distance = (LocalPlayer.Character.PrimaryPart.Position - Ball.Position).Magnitude
                local Speed = Zoomies.VectorVelocity.Magnitude
                local Ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue() / 10
                local ParryRange = (Speed / 3.25) + Ping

                if Distance <= ParryRange then
                    Auto_Parry.Parry()
                    Parried = true

                    task.delay(1, function()
                        Parried = false
                    end)
                end
            end
        end)
    else
        if Connections_Manager["Auto Parry"] then
            Connections_Manager["Auto Parry"]:Disconnect()
            Connections_Manager["Auto Parry"] = nil
        end
    end
end)

-- Auto Spam Toggle (clean version)
local AutoSpamEnabled = false
local AutoSpamLoop = nil

MainTab:AddToggle("Auto Spam", AutoSpamEnabled, function(state)
    AutoSpamEnabled = state

    if state then
        AutoSpamLoop = task.spawn(function()
            while AutoSpamEnabled do
                task.wait()

                local ball = Auto_Parry.Get_Ball()
                if not ball or not ball:FindFirstChild("zoomies") then continue end

                Auto_Parry.Closest_Player()
                local target = Closest_Entity
                if not target or not target.PrimaryPart then continue end

                local myDist = LocalPlayer:DistanceFromCharacter(ball.Position)
                local targetDist = LocalPlayer:DistanceFromCharacter(target.PrimaryPart.Position)

                if (myDist <= 30 or targetDist <= 30) and Parries > 1 then
                    Auto_Parry.Parry()
                end
            end
        end)
    else
        if AutoSpamLoop then
            task.cancel(AutoSpamLoop)
            AutoSpamLoop = nil
        end
    end
end)

-- Manual Spam (as a button, not toggle)
MainTab:AddButton("Manual Spam", function()
    ManualSpam()
end)
return d
